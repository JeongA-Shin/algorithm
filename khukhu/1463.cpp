#include <iostream>
using namespace std;
 
int d[1000005]; //탑 다운방식 - 재귀 //d[n]은 n에 대하여 1이 되는 최소 연산 횟수 !!재귀는 트리로 생각!!!
int dp[1000005]; // 바텀 업 방식 - 반복문 //dp[n]은 n에 대하여 1이 되는 최소 연산 횟수

int go(int n);
int main() {

	//가능한 경우는 3가지
	/* 1. N이 3으로 나누어 떨어진다면 3으로 나눈다
	* 2. N이 2로 나누어 떨어진다면 2로 나눈다
	* 3. 위의 두 경우 모두에 해당되지 않는다면 1을 뺸다
	* 
	* 
	* d[N]을 N을 1로 바꾸는데 필요한 최소 연산 횟수라고 해보자
	* 
	* 그러면 만약 3으로 나누어 떨어진다면(1번 경우라면) 연산 횟수는
	* d[N/3]+1 (1+d[N/3])이다.
	* (왜냐면 3으로 나누어 떨어지므로 나누었기 때문에 나눗셈 1번+ 남은 수는 N/3이므로 얘의 최소는 d[N/3]이므로
	* 
	* 위와 같은 생각과 마찬가지로 2로 나누어 떨어진다면(2번 경우라면)
	* d[N/2]+1
	* 
	* 1,2, 모두에 해당되지 않는다면 (3번이라면)
	* d[N-1]+1
	* 
	* 그럼 N이 1의 경우인지 2의 경우인지 3의 경우인지 어케 알까?
	* 
	* 그리고 우리가 따지는 것은 최소 "연산"횟수임. 즉 한 번의 연산(/3이든 /2이든 -1을 하든)을 한 후 가능한 한에서 제일 최소값이 나와야 함
	* 따라서 
	* d[n]=min(d[n/3]+1,d[n/2]+1,d[n-1]+1) 이렇게임 
	* 그리고 이게 점화식임
	* 
	* 그리고 다이나믹 프로그래밍은 탑다운 혹은 바텀업으로 풀어야 하는데
	* 탑다운은 재귀, 바텀 업은 반복문을 사용해서 푼다
	* 
	*/

	int input;
	cin >> input;

	//바텀 업 방식
	// 가장 작은 문제를 1로 둔다. 왜? 여기서 원하고하자는것은 1에 최소횟수이므로, dp[num==1]일 경우를 가장 작은 경우로 두고 푸는것임.
	dp[1] = 0; //1은 연산횟수가 0
	// 가장 작은문제로 두었기때문에 그다음문제부터 입력한 수까지의 값을 반복문을 돌리게 한다.
	for (int i = 2; i <=input; i++) {
		dp[i] = dp[i - 1] + 1;

		// i를 3으로 나누었을때 0 이며, 나눈값이 기존의 dp[num]값보다 작을때 값을 바꿔준다.(최소값)
		if (i % 3 == 0 && dp[i] > dp[i / 3] + 1) {
			dp[i] = dp[i / 3] + 1;
		}

		// i를 2으로 나누었을때 0 이며, 나눈값이 기존의 dp[num]값보다 작을때 값을 바꿔준다.(최소값)
		if (i % 2 == 0 && dp[i] > dp[i / 2] + 1) {

			dp[i] = dp[i / 2] + 1;

		}

	}

	cout << dp[input] << endl;

	//탑 다운 방식 //재귀는 트리로 생각!!!
	cout << go(input) << endl;


}


//탑 다운 방식
//재귀는 트리로 생각!!!
int go(int n) {

	//재귀종료 조건
	if (n == 1) {
		return 0; //d[1]=0;
	}
	if (d[n] > 0) { //// dp값이 0보다 큰 경우(값이 있는경우== 값이 저장되어있는경우)
		return d[n];
	}


	d[n] = go(n-1) + 1;//3번의 경우를 일단 최소라는 디폴트로 깔고 들어감//즉 일단 메모

	if (n % 3 == 0) { //1번의 경우
		int temp = go(n / 3) + 1;
		if (d[n] > temp) { // 만약 1번의 경우가 더 최소 횟수이면
			d[n] = temp; //최솟값으로 바꿈
		}
	}
	else if (n % 2 == 0) { //2번의 경우
		int temp = go(n / 2) + 1;
		if (d[n] > temp) { // 만약 2번의 경우가 더 최소 횟수이면
			d[n] = temp; //최솟값으로 바꿈
		}
	}
	
	
	return d[n];
}